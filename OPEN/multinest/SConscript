import os
import commands

Import('MPI')
launch_dir = GetLaunchDir()
MultiNest_dir = os.path.join(launch_dir, 'MultiNest/MultiNest_v3.7')

env = Environment()

bld = Builder(action = 'ln -s -f $SOURCE $TARGET')
env.Append(BUILDERS={'SYMLINK': bld})

rvN = Command("get_rvN.f90", "../ext/get_rvN.f90", Copy("$TARGET", "$SOURCE"))

## get path to mpif90 executable
if MPI:
	out = commands.getstatusoutput('which mpif90')
	if out[0] == 0:
		mpif90_exec = out[1]
		mpif90_version = commands.getoutput(mpif90_exec + ' -v').split('\n')[0]
		print 'Found %s at %s' % (mpif90_version, mpif90_exec)
	else:
		raise RuntimeError('Compiling with MPI but mpif90 does not seem to be installed. Aborting!')

# # Configure the f90 compiler
FFLAGS = '-O3 -w -Wno-unused-parameter -ffree-line-length-none'
if MPI: FFLAGS += ' -DMPI -lmpi'

FFLAGS += ' -I' + MultiNest_dir

env = env.Clone(tools=['gfortran'],
	            F90=mpif90_exec if MPI else 'gfortran',
	            LINK=mpif90_exec if MPI else 'gfortran',
	            # LINKFLAGS=LINK,
	            F90FLAGS=FFLAGS,
	            LIBS=['nest3', 'lapack', 'blas'], 
	            LIBPATH=MultiNest_dir,
	            FORTRANMODDIRPREFIX = '-J',  # option used by gfortran to specify where to put .mod files for compiled modules
	            FORTRANMODDIR='.'
	            )

if GetOption('gfortran') is None:
	pass
else:
	if MPI:
		env['F90FLAGS'] += ' -f90=' + GetOption('gfortran')
		# print env['F90FLAGS']
	else:
		env['F90'] = GetOption('gfortran')
		# print env['F90']

source_files = Glob('*.f90') + Glob('*.F90')
# remove file which is to be compiled by F2PY
source_files = [f for f in source_files if 'gp_python_wrapper.f90' not in str(f)] 

# explicitly compile the source files to object+mod files
comps = env.SharedObject(source_files)
Depends(comps, rvN)

# only object files without .mod
objs = [obj for obj in comps if obj.get_suffix() in (".o", ".os")]


nest = env.Program('nest', objs)